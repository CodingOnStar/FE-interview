### 1.谈谈变量提升
在生成执行环境时，会有两个阶段：
1.  创建的阶段，JS解释器给变量和函数开辟好内存的空间，是变量，就声明且赋值为undefined，函数的话就将整个函数存入内存中
2.  代码执行阶段

### 3.实现一个bind函数
可以从两方面思考：
* 不传入第一个参数，那么默认为window
* 改变了this指向，让新的对象可以执行该函数。那么思路是否可以变成给新的对象添加一个函数，然后再执行完以后删除
```js
Function.prototype.myBind = function (context) {
  if (typeof this !== 'function') {
    throw new TypeError('Error')
  }
  var _this = this
  var args = [...arguments].slice(1)
  // 返回一个函数
  return function F() {
    // 因为返回了一个函数，我们可以 new F()，所以需要判断
    if (this instanceof F) {
      return new _this(...args, ...arguments)
    }
    return _this.apply(context, args.concat(...arguments))
  }
}
```
### 4.实现一个call函数
```js
Function.prototype.myCall = function(context){
    var context = context || window
    context.fn = this;
    var args = [...arguments].slice(1)
    var result = context.fn(...args)
    delete context.fn
    return result
}
```
### 5.实现一个apply函数
```js
Function.prototype.myApply = function (context) {
    var context = context || window
    var result
    context.fn = this
    if(arguments[1]){
        result = context.fn(...arguments[1])
    }else{
        result = context.fn()
    }
    delete context.fn
    return result
}